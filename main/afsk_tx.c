/*
 * AFSK modulation for transmitter. 
 * 
 * Adapted from Polaric Tracker code. 
 * By LA7ECA, ohanssen@acm.org and LA3T.
 */


#include <stdbool.h>
#include <stdint.h>
#include "afsk.h"
#include "defines.h"
#include "system.h"


#define AFSK_FREQ 1200
#define CLOCK_DIVIDER 16
#define CLOCK_FREQ (TIMER_BASE_CLK / CLOCK_DIVIDER)
#define FREQ(f)    (CLOCK_FREQ/(f))

#define AFSK_TX_TIMERGRP 1
#define AFSK_TX_TIMERIDX 1

static QueueHandle_t oq;
static bool transmit = false; 






/*********************************************************************
 * Turn on/off transmitter and tone generator
 *********************************************************************/
// FIXME: Can this be safely called from the ISR? 
void afsk_PTT(bool on) 
{
   transmit = on; 
//   radio_PTT(on); // FIXME
   if (on) 
      tone_start();
   else
      tone_stop();
}



/**************************************************************************
 * Get next bit from stream
 * Note: see also get_bit() in hdlc_decoder.c 
 * Note: The next_byte must ALWAYS be called before get_bit is called
 * to get new bytes from stream. 
 *************************************************************************/

static uint8_t bits;
static uint8_t bit_count = 0;

static uint8_t get_bit(void)
{
    if (bit_count == 0) 
        return 0;
    uint8_t bit = bits & 0x01;
    bits >>= 1;
    bit_count--;
    return bit;
}


static void next_byte(void)
{
    if (bit_count == 0) 
    {
        /* Turn off TX if queue is empty (have reached end of frame) */
        if (xQueueIsQueueEmptyFromISR(oq)) {
            afsk_PTT(false);  
            return;
        }
        xQueueReceiveFromISR( oq, (void *) &bits, NULL);
        bit_count = 8;    
    } 
}



/*******************************************************************************
 * When transmitting, this function should be called periodically, 
 * at same rate as wanted baud rate.
 *
 * It is responsible for transmitting frames by toggling the frequency of
 * the tone generated by the timer handler below. 
 *******************************************************************************/ 

static void afsk_txBitClock(void *arg) 
{
    clock_clear_intr(AFSK_TX_TIMERGRP, AFSK_TX_TIMERIDX);
    if (!transmit) {
        if (xQueueIsQueueEmptyFromISR(oq))   
            return;
        else {
            /* If bytes in queue, start transmitting */
            next_byte();
            afsk_PTT(true);
        }
    }       
    if ( ! get_bit() ) 
        /* Toggle TX frequency */ 
        tone_toggle(); 
     
    /* Update byte from stream if necessary. We do this 
     * separately, after the get_bit, to make the timing more precise 
     */  
    next_byte();  
}
 

 
 
/***********************************************************
 *  Init.
 ***********************************************************/

QueueHandle_t afsk_tx_init()
{
    tone_init();
    clock_init(AFSK_TX_TIMERGRP, AFSK_TX_TIMERIDX, CLOCK_DIVIDER, afsk_txBitClock, false);
    oq =  xQueueCreate(AFSK_TX_QUEUE_SIZE, 1);
    return oq;
}
 
 
/***********************************************************
 *  Start transmitter.
 ***********************************************************/
 
void afsk_tx_start() {
    clock_start(AFSK_TX_TIMERGRP, AFSK_TX_TIMERIDX, FREQ(AFSK_FREQ));
}
 
 
 
/***********************************************************
 *  Stop transmitter.
 ***********************************************************/
 
 void afsk_tx_stop() {
    clock_stop(AFSK_TX_TIMERGRP, AFSK_TX_TIMERIDX); 
 }
 
 
 
